fun parse_input(path: Path): List<Int> {
  path
  .read()
  .or_error()
  .lines()
  .map(fun(s: String) { parse_int(s).or_error() })
}

fun solve(nums: List<Int>, target: Int): Option<Int> {
  let seen = []
  
  for num in nums {
    let need = target - num
    if nums.contains(need) {
      return Some(num * need)
    }
    seen.append(num)
  }
  
  None
}

fun solve1(nums: List<Int>): Option<Int> {
  solve(nums, 2020)
}

fun solve2(nums: List<Int>): Option<Int> {
  for num in nums {
    let need = 2020 - num
    match solve(nums, need) {
      Some(value) => return Some(num * value)
      None => continue
    }
  }
  
  None
}

test sample_input {
  let nums = [1721, 979, 366, 299, 675, 1456]

  assert(solve1(nums) == Some(514579))
  assert(solve2(nums) == Some(241861950))
}

test full_input {
  let path = working_directory().join("input/aoc01.txt")
  let nums = parse_input(path)

  assert(solve1(nums) == Some(776064))
  assert(solve2(nums) == Some(6964490))
}

fun (this: Int) is_even(): Bool {
  (this % 2) == 0
}

fun (this: Int) is_odd(): Bool {
  this.is_even().not()
}

// exp_by_squaring_iterative algorithm from wikipedia:
// https://en.wikipedia.org/wiki/Exponentiation_by_squaring
fun (this: Int) pow(power: Int): Int {
  let x = this
  let n = power
  
  if power < 0 {
    x = 1 / x
    n = n * -1
  }
  
  if n == 0 {
    return 1
  }
  
  let y = 1
  while n > 1 {
    if n.is_odd() {
      y = x * y
      n = n - 1
    }
    x = x * x
    n = n / 2
  }
  
  x * y
}

fun parse_int(s: String): Result<Int, String> {
  let digits = "0123456789"
  let result = 0

  for i in range(0, s.len()) {
    let char = s.substring(i, i + 1)
    match digits.index_of(char) {
      Some(num) => {
	result += num * 10.pow(s.len() - (i + 1))
      },
      None => return Err("Unable to parse Int")
    }
  }

  Ok(result)
}
